```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mandem.os Key Holders Mapper</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#7c5cff;--accent-2:#00d4ff;--glass:rgba(255,255,255,0.03)}
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    html,body{height:100%;margin:0;background:
      radial-gradient(1200px 600px at 10% 10%, rgba(124,92,255,0.12), transparent 8%),
      radial-gradient(900px 400px at 90% 90%, rgba(0,212,255,0.06), transparent 6%),
      var(--bg);color:#e6eef6}
    .wrap{max-width:1100px;margin:32px auto;padding:28px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:14px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    header{display:flex;gap:18px;align-items:center;margin-bottom:18px}
    .logo{width:64px;height:64px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:700;color:#051025}
    h1{font-size:20px;margin:0}
    p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    .card{background:var(--card);padding:16px;border-radius:12px;border:1px solid var(--glass)}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=text], input[type=number], select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:14px}
    .row{display:flex;gap:10px}
    .btn{display:inline-flex;align-items:center;gap:10px;padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#021024;font-weight:600;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .small{font-size:13px}
    .progress{height:8px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden;margin-top:10px}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%}
    table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px}
    th,td{padding:8px 10px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.02)}
    th{font-size:12px;color:var(--muted);font-weight:600}
    tfoot td{padding-top:12px;color:var(--muted)}
    .muted{color:var(--muted)}
    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:14px;color:var(--muted);font-size:13px}
    pre{white-space:pre-wrap;word-break:break-word;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;font-size:12px;color:var(--muted)}
    .flex-col{display:flex;flex-direction:column;gap:12px}
    @media (max-width:980px){.grid{grid-template-columns:1fr;}.wrap{margin:14px}}
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <header>
      <div class="logo">MD</div>
      <div>
        <h1>mandem.os Key Holders Mapper</h1>
        <p class="lead">Scan an ERC-1155 contract for Transfer events, reconstruct tokenId balances, and export holder CSV.</p>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="flex-col">
          <div>
            <label>RPC URL</label>
            <input id="rpc" type="text" placeholder="https://eth-mainnet.g.alchemy.com/v2/yourKey or https://cloudflare-eth.com" value="https://cloudflare-eth.com" />
          </div>

          <div>
            <label>Contract Address</label>
            <input id="contract" type="text" value="0x45a328572b2a06484e02EB5D4e4cb6004136eB16" />
          </div>

          <div class="row">
            <div style="flex:1">
              <label>Token ID</label>
              <input id="tokenId" type="number" value="1" />
            </div>
            <div style="width:160px">
              <label>Start Block</label>
              <input id="startBlock" type="number" placeholder="deployment block (optional)" />
            </div>
          </div>

          <div class="row">
            <button id="scanBtn" class="btn">Scan and Reconstruct</button>
            <button id="fetchHoldersBtn" class="btn ghost">Fetch Verified Holders</button>
            <button id="downloadBtn" class="btn ghost">Download CSV</button>
          </div>

          <div>
            <label>Progress</label>
            <div class="progress" aria-hidden="true"><i id="bar" style="width:0%"></i></div>
            <div style="display:flex;justify-content:space-between;margin-top:8px">
              <div class="muted small" id="status">idle</div>
              <div class="muted small" id="eta"></div>
            </div>
          </div>

          <div>
            <label>Logs</label>
            <pre id="log">Ready.</pre>
          </div>
        </div>
      </section>

      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-size:13px;color:var(--muted)">Contract</div>
            <div id="contractDisplay" style="font-weight:700;word-break:break-all">0x45a32857...6eB16</div>
          </div>
          <div style="text-align:right">
            <div class="muted small">Total Holders (recon)</div>
            <div id="count" style="font-weight:700;font-size:20px">0</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <table aria-live="polite">
            <thead>
              <tr><th>address</th><th style="width:110px">balance</th></tr>
            </thead>
            <tbody id="tableBody">
            </tbody>
            <tfoot>
              <tr><td colspan="2" id="tableFooter" class="muted">No data</td></tr>
            </tfoot>
          </table>
        </div>

        <div class="footer">
          <div class="muted small">Note: browser RPC providers can rate-limit large log queries.</div>
          <div class="muted small">Output: CSV</div>
        </div>
      </aside>
    </div>
  </div>

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@6.8.1/dist/ethers.esm.min.js';

    const $ = id => document.getElementById(id);
    const logEl = $('log'), bar = $('bar'), statusEl = $('status'), etaEl = $('eta');
    const scanBtn = $('scanBtn'), fetchHoldersBtn = $('fetchHoldersBtn'), downloadBtn = $('downloadBtn');
    const tableBody = $('tableBody'), countEl = $('count'), contractDisplay = $('contractDisplay'), tableFooter = $('tableFooter');

    let reconHolders = []; // {address, balance}
    let isScanning = false; // Prevent concurrent scans

    // Configuration constants
    const INITIAL_RETRY_DELAY = 1000; // milliseconds
    const MAX_RETRY_DELAY = 8000; // milliseconds
    const MAX_RETRIES = 3; // maximum retry attempts per request
    const MIN_STEP_SIZE = 1000; // blocks
    const STEP_REDUCTION_THRESHOLD = 2; // retry attempts before reducing step
    const RATE_LIMIT_BATCH_SIZE = 10; // calls before delay
    const RATE_LIMIT_DELAY = 100; // milliseconds
    const ADDITIONAL_RATE_LIMIT_DELAY = 200; // milliseconds for additional throttling
    const DISPLAY_LIMIT = 2000; // max holders to display in table
    const MAX_BLOCK_SEARCH_RANGE = 8000000; // blocks to search for contract deployment

    /**
     * Appends a timestamped message to the log display
     * @param {string} msg - The message to log
     */
    function appendLog(msg){
      const now = new Date().toISOString().slice(11,23);
      logEl.textContent = `${now}  ${msg}\n` + logEl.textContent;
    }

    /**
     * Updates the progress bar percentage
     * @param {number} p - Progress percentage (0-100)
     */
    function setProgress(p){ bar.style.width = Math.max(0, Math.min(100,p)) + '%'; }

    /**
     * Converts holder data to CSV format
     * @param {Array<{address: string, balance: string}>} rows - Holder data
     * @returns {string} CSV formatted string
     */
    function toCSV(rows){
      const header = ['address','balance'];
      const lines = [header.join(',')].concat(rows.map(r => `${r.address},${r.balance}`));
      return lines.join('\n');
    }

    /**
     * Validates Ethereum address format
     * @param {string} address - Address to validate
     * @returns {boolean} True if valid
     */
    function isValidAddress(address){
      return /^0x[a-fA-F0-9]{40}$/.test(address);
    }

    /**
     * Validates RPC URL format
     * @param {string} url - URL to validate
     * @returns {boolean} True if valid
     */
    function isValidRpcUrl(url){
      try {
        const parsed = new URL(url);
        return parsed.protocol === 'http:' || parsed.protocol === 'https:';
      } catch {
        return false;
      }
    }

    /**
     * Queries blockchain logs in chunks with automatic retry and adaptive step sizing
     * @async
     * @param {ethers.Provider} provider - The RPC provider
     * @param {string} contractAddress - Contract address to query
     * @param {Array<string>} topics - Event topics to filter
     * @param {number} fromBlock - Starting block number
     * @param {number} toBlock - Ending block number (optional)
     * @param {number} step - Initial chunk size (default 5000)
     * @returns {Promise<Array>} Array of log objects
     */
    async function queryLogs(provider, contractAddress, topics, fromBlock, toBlock, step=5000){
      const logs = [];
      const latest = toBlock ?? await provider.getBlockNumber();
      let start = fromBlock;
      if (!start) start = 0;
      appendLog(`queryLogs: scanning ${start} → ${latest} in steps of ${step}`);
      
      const startTime = Date.now();
      let retriesCount = 0;
      
      for (let from = start; from <= latest; from += step){
        const to = Math.min(from + step - 1, latest);
        let retries = 0;
        let success = false;
        
        while (!success && retries < MAX_RETRIES){
          try {
            appendLog(`fetching ${from}→${to}${retries > 0 ? ` (retry ${retries})` : ''}`);
            const chunk = await provider.getLogs({ fromBlock: from, toBlock: to, address: contractAddress, topics });
            logs.push(...chunk);
            setProgress( Math.round( (to / latest) * 60 ) );
            
            // Update ETA
            const elapsed = Date.now() - startTime;
            const progress = (to - start) / (latest - start);
            if (progress > 0.01){
              const eta = Math.round((elapsed / progress - elapsed) / 1000);
              etaEl.textContent = `ETA: ${eta}s`;
            }
            success = true;
          } catch (err){
            retries++;
            retriesCount++;
            appendLog(`log error ${from}-${to}: ${err.message || err}${retries < MAX_RETRIES ? ', retrying...' : ''}`);
            
            if (retries < MAX_RETRIES){
              // Exponential backoff
              const waitTime = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, retries - 1), MAX_RETRY_DELAY);
              await new Promise(r=>setTimeout(r, waitTime));
              
              // Reduce step size on repeated failures
              if (retries === STEP_REDUCTION_THRESHOLD && step > MIN_STEP_SIZE) {
                step = Math.max(MIN_STEP_SIZE, Math.floor(step/2));
                appendLog(`reducing step size to ${step}`);
              }
            } else {
              appendLog(`failed after ${MAX_RETRIES} retries, skipping range ${from}-${to}`);
              success = true; // Move on to avoid infinite loop
            }
          }
        }
        
        // Small delay to avoid rate limiting
        if (retriesCount > 2) await new Promise(r=>setTimeout(r, ADDITIONAL_RATE_LIMIT_DELAY));
      }
      setProgress(70);
      etaEl.textContent = '';
      return logs;
    }

    /**
     * Attempts to decode a TransferSingle event log
     * @param {ethers.Interface} iface - Contract interface
     * @param {Object} log - Raw log object
     * @returns {Object|null} Parsed log or null if decode fails
     */
    function decodeTransferSingle(iface, log){
      try {
        return iface.parseLog(log);
      } catch { return null; }
    }

    /**
     * Attempts to decode a TransferBatch event log
     * @param {ethers.Interface} iface - Contract interface
     * @param {Object} log - Raw log object
     * @returns {Object|null} Parsed log or null if decode fails
     */
    function decodeTransferBatch(iface, log){
      try {
        return iface.parseLog(log);
      } catch { return null; }
    }

    /**
     * Processes transfer events to reconstruct token balances
     * @param {Array} logs - Array of event logs
     * @param {ethers.Interface} iface - Contract interface
     * @param {string} tokenId - Token ID to track
     * @returns {Array<{address: string, balance: string}>} Sorted array of holders with positive balances
     */
    function processEventsToBalances(logs, iface, tokenId){
      const balances = new Map();
      let processedEvents = 0;
      
      for (const l of logs){
        const parsed = decodeTransferSingle(iface, l) || decodeTransferBatch(iface, l);
        if (!parsed) continue;
        
        processedEvents++;
        const name = parsed.name;
        
        if (name === 'TransferSingle'){
          const from = parsed.args.from.toLowerCase();
          const to = parsed.args.to.toLowerCase();
          const id = parsed.args.id.toString();
          const value = BigInt(parsed.args.value.toString());
          if (id !== tokenId) continue;
          if (from !== ethers.ZeroAddress){
            const a = BigInt(balances.get(from) ?? 0n) - value;
            balances.set(from, a.toString());
          }
          if (to !== ethers.ZeroAddress){
            const a = BigInt(balances.get(to) ?? 0n) + value;
            balances.set(to, a.toString());
          }
        } else if (name === 'TransferBatch'){
          const from = parsed.args.from.toLowerCase();
          const to = parsed.args.to.toLowerCase();
          const ids = parsed.args.ids;
          const values = parsed.args.values;
          for (let i=0;i<ids.length;i++){
            const id = ids[i].toString();
            if (id !== tokenId) continue;
            const value = BigInt(values[i].toString());
            if (from !== ethers.ZeroAddress){
              const a = BigInt(balances.get(from) ?? 0n) - value;
              balances.set(from, a.toString());
            }
            if (to !== ethers.ZeroAddress){
              const a = BigInt(balances.get(to) ?? 0n) + value;
              balances.set(to, a.toString());
            }
          }
        }
      }
      
      appendLog(`processed ${processedEvents} relevant events from ${logs.length} total logs`);
      
      const out = [];
      for (const [addr, balStr] of balances.entries()){
        const bal = BigInt(balStr);
        if (bal > 0n) out.push({ address: addr, balance: bal.toString() });
      }
      out.sort((a,b)=> (BigInt(b.balance) > BigInt(a.balance) ? 1 : -1));
      return out;
    }

    /**
     * Verifies reconstructed balances against on-chain state
     * @async
     * @param {ethers.Provider} provider - The RPC provider
     * @param {string} contractAddress - Contract address
     * @param {ethers.Interface} iface - Contract interface
     * @param {Array<{address: string, balance: string}>} candidates - Candidate holders
     * @param {string} tokenId - Token ID to verify
     * @returns {Promise<Array<{address: string, balance: string}>>} Verified holders with actual balances
     */
    async function verifyOnChain(provider, contractAddress, iface, candidates, tokenId){
      const out = [];
      appendLog(`verifying ${candidates.length} addresses on-chain`);
      let i = 0;
      let failedCount = 0;
      const startTime = Date.now();
      
      for (const c of candidates){
        try {
          const data = iface.encodeFunctionData('balanceOf',[c.address, tokenId]);
          const res = await provider.call({ to: contractAddress, data });
          const decoded = iface.decodeFunctionResult('balanceOf', res)[0];
          const bal = BigInt(decoded.toString());
          if (bal > 0n) out.push({ address: c.address, balance: bal.toString() });
          
          // Small delay every N calls to avoid rate limiting
          if (i > 0 && i % RATE_LIMIT_BATCH_SIZE === 0){
            await new Promise(r=>setTimeout(r, RATE_LIMIT_DELAY));
            
            // Update ETA
            const elapsed = Date.now() - startTime;
            const progress = i / candidates.length;
            const eta = Math.round((elapsed / progress - elapsed) / 1000);
            etaEl.textContent = `ETA: ${eta}s`;
          }
        } catch (err){
          failedCount++;
          appendLog(`verify error ${c.address}: ${err.message || err}`);
        }
        i++;
        setProgress(70 + Math.round((i / candidates.length) * 25));
      }
      
      if (failedCount > 0){
        appendLog(`verification completed with ${failedCount} failures`);
      }
      
      out.sort((a,b)=> (BigInt(b.balance) > BigInt(a.balance) ? 1 : -1));
      setProgress(95);
      etaEl.textContent = '';
      return out;
    }

    scanBtn.addEventListener('click', async ()=>{
      // Prevent concurrent scans
      if (isScanning){
        appendLog('scan already in progress');
        return;
      }
      
      const rpc = $('rpc').value.trim();
      const contractAddress = $('contract').value.trim();
      const tokenId = $('tokenId').value.toString();
      const startBlockInput = $('startBlock').value.trim();

      // Input validation
      if (!rpc) {
        appendLog('error: RPC URL is required');
        statusEl.textContent = 'error: missing RPC URL';
        return;
      }
      if (!isValidRpcUrl(rpc)) {
        appendLog('error: invalid RPC URL format');
        statusEl.textContent = 'error: invalid RPC URL';
        return;
      }
      if (!contractAddress) {
        appendLog('error: contract address is required');
        statusEl.textContent = 'error: missing contract address';
        return;
      }
      if (!isValidAddress(contractAddress)) {
        appendLog('error: invalid contract address format');
        statusEl.textContent = 'error: invalid contract address';
        return;
      }
      if (!tokenId || tokenId === 'NaN') {
        appendLog('error: token ID is required');
        statusEl.textContent = 'error: missing token ID';
        return;
      }
      
      isScanning = true;
      scanBtn.disabled = true;
      scanBtn.textContent = 'Scanning...';
      contractDisplay.textContent = contractAddress;
      appendLog('creating provider');
      statusEl.textContent = 'initializing';
      setProgress(0);
      
      try{
        const provider = new ethers.JsonRpcProvider(rpc);
        
        // Test provider connection
        try {
          await provider.getBlockNumber();
          appendLog('provider connection successful');
        } catch (err) {
          throw new Error(`failed to connect to RPC: ${err.message}`);
        }
        
        const iface = new ethers.Interface([
          "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)",
          "event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)",
          "function balanceOf(address account, uint256 id) view returns (uint256)"
        ]);
        const topicSingle = iface.getEventTopic('TransferSingle');
        const topicBatch = iface.getEventTopic('TransferBatch');
        const startBlock = startBlockInput ? Number(startBlockInput) : 0;
        const latest = await provider.getBlockNumber();

        appendLog(`latest block ${latest}`);
        appendLog(`scanning from block ${startBlock} to ${latest} (${latest - startBlock} blocks)`);
        statusEl.textContent = 'querying logs';
        
        const logsSingle = await queryLogs(provider, contractAddress, [topicSingle], startBlock, latest, 50000);
        const logsBatch = await queryLogs(provider, contractAddress, [topicBatch], startBlock, latest, 50000);
        
        appendLog(`logs fetched: single=${logsSingle.length} batch=${logsBatch.length}`);
        const allLogs = logsSingle.concat(logsBatch).sort((a,b)=> (a.blockNumber - b.blockNumber));
        appendLog(`total events ${allLogs.length}`);
        
        if (allLogs.length === 0){
          appendLog('warning: no transfer events found for this token');
          statusEl.textContent = 'no events found';
        } else {
          statusEl.textContent = 'reconstructing';
          reconHolders = processAndDisplay(allLogs, iface, tokenId);
          setProgress(90);
          statusEl.textContent = 'reconstruction complete';
          tableFooter.textContent = `Reconstructed ${reconHolders.length} candidate holders (verify to confirm on-chain balances)`;
          appendLog('reconstruction finished');
        }
      } catch (err){
        appendLog('scan failed: ' + (err.message || err));
        statusEl.textContent = 'error';
        tableFooter.textContent = 'Scan failed - check logs for details';
      } finally {
        isScanning = false;
        scanBtn.disabled = false;
        scanBtn.textContent = 'Scan and Reconstruct';
        setProgress(0);
      }
    });

    /**
     * Processes logs and displays results in the table
     * @param {Array} allLogs - All event logs
     * @param {ethers.Interface} iface - Contract interface
     * @param {string} tokenId - Token ID
     * @returns {Array<{address: string, balance: string}>} Holder data
     */
    function processAndDisplay(allLogs, iface, tokenId){
      const parsed = allLogs.map(l=>{
        try { return iface.parseLog(l); } catch { return null; }
      }).filter(x=>x);
      // Because parseLog returns same shape for both TransferSingle and TransferBatch we can reuse
      const holders = processEventsToBalances(allLogs, iface, tokenId);
      tableBody.innerHTML = '';
      const displayHolders = holders.slice(0, DISPLAY_LIMIT);
      
      for (const h of displayHolders){
        const tr = document.createElement('tr');
        const a = document.createElement('td'); a.textContent = h.address;
        const b = document.createElement('td'); b.textContent = h.balance;
        tr.appendChild(a); tr.appendChild(b);
        tableBody.appendChild(tr);
      }
      
      countEl.textContent = holders.length.toString();
      
      if (holders.length > DISPLAY_LIMIT){
        appendLog(`displaying first ${DISPLAY_LIMIT} of ${holders.length} holders`);
      }
      
      return holders;
    }

    fetchHoldersBtn.addEventListener('click', async ()=>{
      if (!reconHolders || reconHolders.length === 0){
        appendLog('error: no candidates to verify - run scan first');
        statusEl.textContent = 'error: no data';
        return;
      }
      
      const rpc = $('rpc').value.trim();
      const contractAddress = $('contract').value.trim();
      const tokenId = $('tokenId').value.toString();
      
      // Input validation
      if (!isValidRpcUrl(rpc)){
        appendLog('error: invalid RPC URL');
        return;
      }
      if (!isValidAddress(contractAddress)){
        appendLog('error: invalid contract address');
        return;
      }
      
      fetchHoldersBtn.disabled = true;
      fetchHoldersBtn.textContent = 'Verifying...';
      
      try {
        const provider = new ethers.JsonRpcProvider(rpc);
        const iface = new ethers.Interface([
          "function balanceOf(address account, uint256 id) view returns (uint256)"
        ]);
        
        statusEl.textContent = 'verifying on-chain';
        appendLog(`starting verification of ${reconHolders.length} addresses`);
        
        const verified = await verifyOnChain(provider, contractAddress, iface, reconHolders, tokenId);
        reconHolders = verified;
        tableBody.innerHTML = '';
        
        for (const h of verified){
          const tr = document.createElement('tr');
          const a = document.createElement('td'); a.textContent = h.address;
          const b = document.createElement('td'); b.textContent = h.balance;
          tr.appendChild(a); tr.appendChild(b);
          tableBody.appendChild(tr);
        }
        
        countEl.textContent = verified.length.toString();
        tableFooter.textContent = `Verified ${verified.length} on-chain holders`;
        appendLog(`verification complete: ${verified.length} holders confirmed`);
        setProgress(100);
        statusEl.textContent = 'done';
      } catch (err){
        appendLog('verify failed: ' + (err.message || err));
        statusEl.textContent = 'error';
        tableFooter.textContent = 'Verification failed - check logs';
      } finally {
        fetchHoldersBtn.disabled = false;
        fetchHoldersBtn.textContent = 'Fetch Verified Holders';
      }
    });

    downloadBtn.addEventListener('click', ()=>{
      if (!reconHolders || reconHolders.length === 0){
        appendLog('error: no data to download');
        statusEl.textContent = 'error: no data';
        return;
      }
      
      try {
        const csv = toCSV(reconHolders);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const tokenId = $('tokenId').value.toString().replace(/[^\d]/g,'') || 'token';
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19); // YYYY-MM-DDTHH-MM-SS
        a.href = url;
        a.download = `holders_token_${tokenId}_${timestamp}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        appendLog(`CSV download initiated: ${reconHolders.length} holders`);
      } catch (err) {
        appendLog(`download failed: ${err.message || err}`);
        statusEl.textContent = 'error';
      }
    });

    // Auto-suggest start block based on contract deployment
    (async function trySuggestStart(){
      try {
        const rpc = $('rpc').value.trim();
        if (!isValidRpcUrl(rpc)) return;
        
        const provider = new ethers.JsonRpcProvider(rpc);
        const address = $('contract').value.trim();
        if (!address || !isValidAddress(address)) return;
        
        appendLog('attempting to detect contract deployment block...');
        const latest = await provider.getBlockNumber();
        
        // Binary search for first non-zero logs presence for address
        let low = Math.max(0, latest - MAX_BLOCK_SEARCH_RANGE);
        let high = latest;
        let foundBlock = null;
        
        for (let i=0; i<6; i++){
          const mid = Math.floor((low+high)/2);
          try {
            const logs = await provider.getLogs({address, fromBlock: mid, toBlock: high, limit: 1});
            if (logs.length > 0){
              foundBlock = logs[0].blockNumber;
              high = mid;
            } else {
              low = Math.max(0, mid+1);
            }
            if (high - low < 2000) break;
          } catch (err) {
            appendLog(`start block detection failed: ${err.message || err}`);
            break;
          }
        }
        
        if (foundBlock){
          const suggestedBlock = Math.max(0, foundBlock - 20);
          $('startBlock').value = suggestedBlock;
          appendLog(`suggested start block: ${suggestedBlock} (contract activity detected at ${foundBlock})`);
        } else {
          appendLog('could not detect contract deployment block automatically');
        }
      } catch (err) {
        appendLog(`start block detection error: ${err.message || err}`);
      }
    })();

  </script>
</body>
</html>
```
